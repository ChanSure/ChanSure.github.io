<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roki</title>
  
  
  <link href="https://www.shuocloud.top/atom.xml" rel="self"/>
  
  <link href="https://www.shuocloud.top/"/>
  <updated>2021-02-22T04:16:45.213Z</updated>
  <id>https://www.shuocloud.top/</id>
  
  <author>
    <name>ChenShuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-766. Toeplitz Matrix（托普利茨矩阵）</title>
    <link href="https://www.shuocloud.top/2021/02/22/LeetCode-766-Toeplitz-Matrix%EF%BC%88%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2021/02/22/LeetCode-766-Toeplitz-Matrix%EF%BC%88%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5%EF%BC%89/</id>
    <published>2021-02-22T04:15:20.000Z</published>
    <updated>2021-02-22T04:16:45.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="托普利茨矩阵"><a href="#托普利茨矩阵" class="headerlink" title="托普利茨矩阵"></a>托普利茨矩阵</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是<strong>托普利茨矩阵</strong> 。</p><a id="more"></a><p><strong>示例1</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/485f6426a7af4d21bfb3d1222ae0a9f3.png"></p><blockquote><p><strong>输入</strong>：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br><strong>输出</strong>：true<br><strong>解释</strong>：<br>在上述矩阵中, 其对角线为:<br>“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”。<br>各条对角线上的所有元素均相同, 因此答案是 True </p></blockquote><p><strong>示例2</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/f895738837ee47c80f73baab11f4d580.png"></p><blockquote><p><strong>输入</strong>：matrix = [[1,2],[2,2]]<br><strong>输出</strong>：false<br><strong>解释</strong>：<br>对角线 “[1, 2]” 上的元素不同</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 20</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li></ul><p> <strong>进阶：</strong></p><ol><li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li><li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li></ol><h2 id="Toeplitz-Matrix"><a href="#Toeplitz-Matrix" class="headerlink" title="Toeplitz Matrix"></a>Toeplitz Matrix</h2><p>Given an <code>m x n</code> matrix, return <code>true</code> if the matrix is Toeplitz. Otherwise, return <code>false</code>.<br>A matrix is <strong>Toeplitz</strong> if every diagonal from top-left to bottom-right has the same elements.<br><strong>Example 1:</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/485f6426a7af4d21bfb3d1222ae0a9f3.png"></p><blockquote><p><strong>Input</strong>: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br><strong>Output</strong>: true<br><strong>Explanation</strong>:<br>In the above grid, the diagonals are:<br>“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”.<br>In each diagonal all elements are the same, so the answer is True.</p></blockquote><p><strong>example 2</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/f895738837ee47c80f73baab11f4d580.png"></p><blockquote><p><strong>Input</strong>: matrix = [[1,2],[2,2]]<br><strong>Output</strong>: false<br><strong>Explanation</strong>:<br>The diagonal “[1, 2]” has different elements.</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 20</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li></ul><p><strong>Follow up:</strong></p><ol><li>What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once?</li><li>What if the matrix is so large that you can only load up a partial row into the memory at once?<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2>我们只需要遍历矩阵时，把当前元素与其左上角的元素比较即可。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != matrix[i - <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>进阶1</strong><br>一次最多只能将矩阵的一行加载到内存中，我们将每一行复制到一个连续数组中，随后在读取下一行第一个元素时，把内存中用不到最后一位调出内存即可，新调入的就与内存中此前保存的数组进行比较。<br><strong>进阶2</strong><br>一次只能将不完整的一行加载到内存中，我们将整个矩阵竖直切分成若干子矩阵，并保证两个相邻的矩阵至少有一列或一行是重合的，然后判断每个子矩阵是否符合要求。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;托普利茨矩阵&quot;&gt;&lt;a href=&quot;#托普利茨矩阵&quot; class=&quot;headerlink&quot; title=&quot;托普利茨矩阵&quot;&gt;&lt;/a&gt;托普利茨矩阵&lt;/h2&gt;&lt;p&gt;给你一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵 &lt;code&gt;matrix&lt;/code&gt; 。如果这个矩阵是托普利茨矩阵，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;br&gt;如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是&lt;strong&gt;托普利茨矩阵&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-697. Degree of an Array（数组的度）</title>
    <link href="https://www.shuocloud.top/2021/02/20/LeetCode-697-Degree-of-an-Array%EF%BC%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2021/02/20/LeetCode-697-Degree-of-an-Array%EF%BC%88%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6%EF%BC%89/</id>
    <published>2021-02-20T06:07:02.000Z</published>
    <updated>2021-02-22T04:14:44.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组的度"><a href="#数组的度" class="headerlink" title="数组的度"></a>数组的度</h2><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。<br>你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p><a id="more"></a><p><strong>示例 1：</strong></p><blockquote><p><strong>输入</strong>：[1, 2, 2, 3, 1]<br><strong>输出</strong>：2<br><strong>解释</strong>：<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>最短连续子数组[2, 2]的长度为2，所以返回2.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入</strong>：[1,2,2,3,1,4,2]<br><strong>输出</strong>：6</p></blockquote><p><strong>提示：</strong></p><ul><li><code>nums.length </code>在<code>1</code>到 <code>50,000</code> 区间范围内。</li><li><code>nums[i]</code> 是一个在 <code>0</code> 到 <code>49,999</code> 范围内的整数。</li></ul><h2 id="Degree-of-an-Array"><a href="#Degree-of-an-Array" class="headerlink" title="Degree of an Array"></a>Degree of an Array</h2><p>Given a non-empty array of non-negative integers <code>nums</code>, the degree of this array is defined as the maximum frequency of any one of its elements.<br>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.<br><strong>Example 1:</strong></p><blockquote><p><strong>Input</strong>: nums = [1,2,2,3,1]<br><strong>Output</strong>: 2<br><strong>Explanation</strong>:<br>The input array has a degree of 2 because both elements 1 and 2 appear twice.<br>Of the subarrays that have the same degree:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>The shortest length is 2. So return 2.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input</strong>: nums = [1,2,2,3,1,4,2]<br><strong>Output</strong>: 6<br><strong>Explanation</strong>:<br>The degree is 3 because the element 2 is repeated 3 times.<br>So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.</p></blockquote><p><strong>Constraints</strong>:</p><ul><li><code>nums.length</code> will be between <code>1</code> and <code>50,000</code>.</li><li><code>nums[i]</code> will be an integer between <code>0</code> and <code>49,999</code>.<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2></li></ul><p><strong>方法一：哈希表</strong><br>假设出现次数最多的元素为$x$，那么所求的数组必然包含所有$x$，最短的情况就是以$x$开始，以$x$结束。若出现次数有多个，选取其中最短的一个数组即可。<br>采用哈希表便于查找，事实上，当测试数据较少的时候，直接使用数组计数的时间开销要小。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Info&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> maxDegree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == hash.count(nums[i])) &#123;</span><br><span class="line">                Info info = &#123;<span class="number">1</span>, i, i + <span class="number">1</span>&#125;;</span><br><span class="line">                hash[nums[i]] = info;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hash[nums[i]].count += <span class="number">1</span>;</span><br><span class="line">                hash[nums[i]].last = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> degree = hash[nums[i]].count;</span><br><span class="line"><span class="keyword">int</span> len = hash[nums[i]].last-hash[nums[i]].first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(maxDegree &lt; degree)&#123;</span><br><span class="line">maxDegree = degree;</span><br><span class="line">minLen = len;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxDegree == degree &amp;&amp; minLen &gt; len)&#123;</span><br><span class="line">minLen = len;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span> first;</span><br><span class="line">        <span class="keyword">int</span> last;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 可以改用向量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数组的度&quot;&gt;&lt;a href=&quot;#数组的度&quot; class=&quot;headerlink&quot; title=&quot;数组的度&quot;&gt;&lt;/a&gt;数组的度&lt;/h2&gt;&lt;p&gt;给定一个非空且只包含非负数的整数数组 &lt;code&gt;nums&lt;/code&gt;，数组的度的定义是指数组里任一元素出现频数的最大值。&lt;br&gt;你的任务是在 &lt;code&gt;nums&lt;/code&gt; 中找到与 &lt;code&gt;nums&lt;/code&gt; 拥有相同大小的度的最短连续子数组，返回其长度。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-995. K连续位的最小翻转次数(Minimum Number of K Consecutive Bit Flips)</title>
    <link href="https://www.shuocloud.top/2021/02/18/LeetCode-995-K%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0-Minimum-Number-of-K-Consecutive-Bit-Flips/"/>
    <id>https://www.shuocloud.top/2021/02/18/LeetCode-995-K%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0-Minimum-Number-of-K-Consecutive-Bit-Flips/</id>
    <published>2021-02-18T05:52:06.000Z</published>
    <updated>2021-02-20T05:55:00.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K连续位的最小翻转次数"><a href="#K连续位的最小翻转次数" class="headerlink" title="K连续位的最小翻转次数"></a>K连续位的最小翻转次数</h2><p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code> 中，一次 <code>K</code> 位翻转包括选择一个长度为 <code>K</code> 的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为 <code>1</code>，而每个 <code>1</code> 更改为 <code>0</code>。</p><p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为 <code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p><a id="more"></a><p><strong>示例 1：</strong></p><blockquote><p><strong>输入</strong>：A = [0,1,0], K = 1<br><strong>输出</strong>：2<br><strong>解释</strong>：先翻转 A[0]，然后翻转 A[2]。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入</strong>：A = [1,1,0], K = 2<br><strong>输出</strong>：-1<br><strong>解释</strong>：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入</strong>：A = [0,0,0,1,0,1,1,0], K = 3<br><strong>输出</strong>：3<br><strong>解释</strong>：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ul><h2 id="Minimum-Number-of-K-Consecutive-Bit-Flips"><a href="#Minimum-Number-of-K-Consecutive-Bit-Flips" class="headerlink" title="Minimum Number of K Consecutive Bit Flips"></a>Minimum Number of K Consecutive Bit Flips</h2><p>In an array <code>A</code> containing only 0s and 1s, a <code>K</code>-bit flip consists of choosing a (contiguous) subarray of length <code>K</code> and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.</p><p>Return the minimum number of <code>K</code>-bit flips required so that there is no 0 in the array.  If it is not possible, return <code>-1</code>.<br><strong>Example 1:</strong></p><blockquote><p>Input: A = [0,1,0], K = 1<br>Output: 2<br>Explanation: Flip A[0], then flip A[2].</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: A = [1,1,0], K = 2<br>Output: -1<br>Explanation: No matter how we flip subarrays of size 2, we can’t make the array become [1,1,1].</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: A = [0,0,0,1,0,1,1,0], K = 3<br>Output: 3<br>Explanation:<br>Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]<br>Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]<br>Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]</p></blockquote><p><strong>Note:</strong></p><ul><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ul><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><blockquote><p><strong>引理1</strong>. 当数组有解时，从头开始，遇到0就翻转，这种解法是最优的。</p></blockquote><p><strong>证明</strong>：我们假设前<code>i-1</code>个元素都是1，对于第<code>i</code>个元素有以下情况：</p><ul><li>第<code>i</code>个元素为1时，我们将其移除窗口即不对其进行翻转操作，这是代价最小的操作。</li><li>第<code>i</code>个元素为0时，要将其变成1，则需要奇数次翻转，因为前<code>i-1</code>个元素都是1，第<code>i</code>个元素一定在窗口头部，因此将其翻转一次并将窗口后移一位，是代价最小的操作。</li></ul><p>下面介绍的方法都是<strong>基于引理1</strong>设计的。</p><p><strong>方法一：差分数组</strong><br>如果我们直接模拟引理1的方法，则会有较大空间开销，因此我们使用<strong>差分数组</strong>。</p><blockquote><p><strong>定义</strong>：对于一个数组<code>a</code>来说，设其差分数组<code>f</code>，则有$f(i) = a(i) - a(i-1)$，其中 $i\geq0$，特殊地，$f(0) = a(0)$.</p></blockquote><p>由定义我们可以得到如下性质：</p><ul><li><strong>性质1</strong>：$a(x)=\sum\limits_{i=0}^{x} {f(i)}$，即$a(x)$等于$f(x)$的前缀和。</li><li><strong>性质2</strong>：由性质1进一步可得$sum(x)=\sum\limits_{i=0}^{x} {a(i)}=\sum\limits_{i=0}^{x} {\sum\limits_{j=0}^{i} {f(j)}}=\sum\limits_{i=0}^{x}{(x-i+1)f(j)}$</li><li><strong>性质3</strong>：对于区间$[L,R]$，将该区间每个元素都加上$x$，由性质1我们知道，将$f(L)+x$后，后面所有的元素在计算前缀和时都会加上$x$，因此我们只需要将$f(R+1)-x$就可以保证区间外的元素不会改变。</li><li><strong>性质4</strong>：由性质2我们可以求得区间$[L,R]$的元素和，即$ans=sum(R)-sum(L-1)$</li></ul><p>介绍完差分数组，我们继续原题的解析。我们设差分数组<code>diff</code>表示相邻两数字翻转次数差，设<code>cnt</code>表示差分数组的累加值即当前数字翻转次数，我们易得以下推论：</p><blockquote><p><strong>推论1</strong>：对于当前元素$a$，若$a+cnt$为偶数，则$a=0$</p></blockquote><p>我们翻转区间时只需要<strong>运用性质3</strong>即可。<br>以下是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cnt += diff[i];</span><br><span class="line">            <span class="keyword">if</span> ((A[i] + cnt) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret++;</span><br><span class="line">                diff[i + <span class="number">1</span>]++;</span><br><span class="line">                diff[i + K]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：滑动窗口</strong><br>在方法一中，我们将记录翻转次数的数据优化成差分数组，在此基础上，思考：是否可以将差分数组优化掉？<br>我们注意到，原数组取值为0或1，那么我们可以用范围外的数来标志该数是否被翻转。具体做法为：<br>若要翻转从位置<code>i</code>开始的子数组，可以将$A[i]+2$，这样当遍历到位置<code>j</code>时，若有$A[j-K]&gt;1$则说明在位置<code>j-K</code>上发生了翻转操作。<br>同时，我们可以将<code>mod 2</code>的操作变成异或操作。<br>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= K &amp;&amp; A[i - K] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                cnt ^= <span class="number">1</span>;</span><br><span class="line">                A[i - K] -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == cnt) &#123; <span class="comment">// A[i] ^ revCnt == 0</span></span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret++;</span><br><span class="line">                cnt ^= <span class="number">1</span>;</span><br><span class="line">                A[i] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;K连续位的最小翻转次数&quot;&gt;&lt;a href=&quot;#K连续位的最小翻转次数&quot; class=&quot;headerlink&quot; title=&quot;K连续位的最小翻转次数&quot;&gt;&lt;/a&gt;K连续位的最小翻转次数&lt;/h2&gt;&lt;p&gt;在仅包含 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 的数组 &lt;code&gt;A&lt;/code&gt; 中，一次 &lt;code&gt;K&lt;/code&gt; 位翻转包括选择一个长度为 &lt;code&gt;K&lt;/code&gt; 的（连续）子数组，同时将子数组中的每个 &lt;code&gt;0&lt;/code&gt; 更改为 &lt;code&gt;1&lt;/code&gt;，而每个 &lt;code&gt;1&lt;/code&gt; 更改为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回所需的 &lt;code&gt;K&lt;/code&gt; 位翻转的最小次数，以便数组没有值为 &lt;code&gt;0&lt;/code&gt; 的元素。如果不可能，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="困难" scheme="https://www.shuocloud.top/categories/LeetCode/%E5%9B%B0%E9%9A%BE/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="滑动窗口" scheme="https://www.shuocloud.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="Sliding Window" scheme="https://www.shuocloud.top/tags/Sliding-Window/"/>
    
    <category term="差分数组" scheme="https://www.shuocloud.top/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
    
    <category term="Difference array" scheme="https://www.shuocloud.top/tags/Difference-array/"/>
    
    <category term="贪心算法" scheme="https://www.shuocloud.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="Greedy" scheme="https://www.shuocloud.top/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>2021年原神拜年纪</title>
    <link href="https://www.shuocloud.top/2021/02/07/2021%E5%B9%B4%E5%8E%9F%E7%A5%9E%E6%8B%9C%E5%B9%B4%E7%BA%AA/"/>
    <id>https://www.shuocloud.top/2021/02/07/2021%E5%B9%B4%E5%8E%9F%E7%A5%9E%E6%8B%9C%E5%B9%B4%E7%BA%AA/</id>
    <published>2021-02-07T11:12:20.000Z</published>
    <updated>2021-02-20T04:41:18.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021年原神拜年纪"><a href="#2021年原神拜年纪" class="headerlink" title="2021年原神拜年纪"></a>2021年原神拜年纪</h2><p>原神拜年纪也很精彩！</p><a id="more"></a><p>原神从开服以来一直都有很大的节奏，除了水军的某些公司的针对以外，很大的原因就是ch不干正经事。近期原神的风评逐渐有好转的迹象，作为内测玩家，我是真心希望原神一直好下去，只要miHoYo把玩家当人看，玩家们还是很友善的。</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=416575036&bvid=BV1FV411i7ok&cid=293566868&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>其中最喜欢的就是那首《让风告诉你》，我永远单推喵酱！（跟不上节奏的七七也好可爱</p><p>中间喵酱那段登录bgm好听到爆！</p><p><strong>如果你厌倦引力想要去飞行</strong><br><strong>我就让全世界的风吹向你</strong></p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=713984017&bvid=BV18X4y1N7Yh&cid=291367405&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>作词 : ChiliChill<br>作曲 : ChiliChill<br>制作人 : ChiliChill<br><strong>当你的天空突然下起了大雨</strong><br><strong>那是我在为你炸乌云</strong><br><strong>当你的发丝微乱有阵风吹过</strong><br><strong>那是我在远处想念你</strong><br>你还在忙吗<br>还是在摸鱼<br>我看看 哇 好大一条<br>那个 摸完能不能借我炸一下<br>嘿嘿嘿<br>看起来你怎么不开心</p><p>虽然不知道发生了什么<br>吃饱了再去想吧<br>这东西 能吃吗<br>烦恼都走开<br>加班都走开<br>倒霉都走开<br>坏人都走开<br>尴尬都走开<br>史莱姆走开<br><strong>当你的天空突然下起了大雨</strong><br><strong>那是我在为你炸乌云</strong><br><strong>当你的发丝微乱有阵风吹过</strong><br><strong>那是我在远处想念你</strong><br>你在忙吗<br>还是在摸鱼<br>我看看 哇 好大一条<br>那个 摸完能不能借她炸一下<br>嘿嘿嘿 哎 唱不完了……<br>（看起来你怎么不开心<br>虽然不知道发生了什么<br>吃饱了再去想吧）<br>不见万家灯火<br>尽斩世间妖魔<br>如此一切只为苍生不要想太多<br>平凡的起起落落<br>漂浮的因果对错<br>都可以向风诉说<br><strong>当前面太多阻碍看不到对岸</strong><br><strong>请替我保密我为你炸平</strong><br><strong>虽然我讨厌热热乎乎的东西</strong><br><strong>我却想要拥抱你可以吗</strong><br>（吟唱）<br><strong>如果你迷恋岁月舍不得向前</strong><br><strong>我就默默记录这诗篇</strong><br><strong>如果你厌倦引力想要去飞行</strong><br><strong>我就让全世界的风吹向你</strong><br><strong>当你的天空突然下起了大雨</strong><br><strong>那是我在为你炸乌云</strong><br><strong>当你的发丝微乱有阵风吹过</strong><br><strong>那是我在远处想念你</strong><br>啦啦啦~<br>演唱：<br>可莉——花玲<br>温迪——喵☆酱<br>七七——宴宁<br>魈——kinsen</p><p>编曲：ChiliChill<br>贝斯：冯子明、山口进也<br>长笛：Salit Lahav<br>弦乐编写：胡静成<br>小提琴：庞阔 / 张浩<br>中提琴：毕芳<br>大提琴：郎莹<br>弦乐录音：李昕达@九紫天诚<br>人声录音棚：YIHE Studio<br>混音、母带：ChiliChill</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2021年原神拜年纪&quot;&gt;&lt;a href=&quot;#2021年原神拜年纪&quot; class=&quot;headerlink&quot; title=&quot;2021年原神拜年纪&quot;&gt;&lt;/a&gt;2021年原神拜年纪&lt;/h2&gt;&lt;p&gt;原神拜年纪也很精彩！&lt;/p&gt;</summary>
    
    
    
    <category term="个人动态" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="原神" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/%E5%8E%9F%E7%A5%9E/"/>
    
    
    <category term="日常谈" scheme="https://www.shuocloud.top/tags/%E6%97%A5%E5%B8%B8%E8%B0%88/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-480.  Sliding Window Median（滑动窗口中位数）</title>
    <link href="https://www.shuocloud.top/2021/02/03/LeetCode-480-Sliding-Window-Median%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2021/02/03/LeetCode-480-Sliding-Window-Median%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%89/</id>
    <published>2021-02-03T04:42:06.000Z</published>
    <updated>2021-02-20T04:45:15.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a>滑动窗口中位数</h2><p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><a id="more"></a><p>例如：</p><ul><li><code>[2,3,4]</code>，中位数是 <code>3</code></li><li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li></ul><p>给你一个数组 <code>nums</code>，有一个长度为 <code>k</code> 的窗口从最左端滑动到最右端。窗口中有 <code>k</code> 个数，每次窗口向右移动 <code>1</code> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。<br><strong>示例：</strong><br>给出 <code>nums = [1,3,-1,-3,5,3,6,7]</code>，以及 <code>k = 3</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">窗口位置                      中位数</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">1</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>      <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>      <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">6</span></span><br></pre></td></tr></table></figure><p> 因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。<br><strong>提示：</strong></p><ul><li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于输入的非空数组的元素个数。</li><li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。<h2 id="Sliding-Window-Median"><a href="#Sliding-Window-Median" class="headerlink" title="Sliding Window Median"></a>Sliding Window Median</h2>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</li></ul><p>Examples:</p><ul><li><code>[2,3,4]</code> , the median is <code>3</code></li><li><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code></li></ul><p>Given an array nums, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p><p><strong>For example,</strong><br>Given nums = <code>[1,3,-1,-3,5,3,6,7]</code>, and <code>k = 3</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Window position                Median</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">1</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>      <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>      <span class="number">-1</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">6</span></span><br></pre></td></tr></table></figure><p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code></p><p><strong>Note:</strong></p><ul><li>You may assume <code>k</code> is always valid, ie: <code>k</code> is always smaller than input array’s size for non-empty array.</li><li>Answers within <code>10^-5</code> of the actual value will be accepted as correct.<h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2></li></ul><p><strong>方法：双向队列</strong></p><p>我们首先要明白如下几点：</p><ul><li>中位数要经过排序后再找</li><li>本题要求我们维护一个滑动窗口，即每次移动都要有元素的加入和退出</li></ul><p>因此我们维护一个大根堆<code>small</code>和一个小根堆<code>large</code>，设当前元素有<code>x</code>个， <code>small</code>负责维护较小的部分，<code>large</code>负责较大的部分，我们有以下引理：</p><blockquote><p><strong>引理1.</strong> <code>small</code> 中的元素个数要么与<code>large</code>中的元素个数相同，要么比<code>large</code>中的元素个数多1个。</p></blockquote><p><strong>证明</strong>：<code>small</code>中有$\lceil \frac{x}{2} \rceil$个元素，<code>large</code>中有$\lfloor \frac{x}{2} \rfloor$个元素，易得引理1正确。<br>由此得到推论：</p><blockquote><p><strong>推论1</strong>. 当两个堆元素个数相等时，两堆顶元素平均值就是中位数，不相等时，<code>small</code>堆顶元素就是中位数。</p></blockquote><p>由推论1我们就可以设计函数<code>getMedian()</code>来求中位数。<br>同时由引理1我们还可以得到推论：</p><blockquote><p><strong>推论2</strong>. 当堆中成功加入一个元素，可能会出现不符合引理1的情况，即如下两种情况</p><ul><li><code>small</code>元素比<code>large</code>多2个</li><li><code>small</code>元素比<code>large</code>少1个</li></ul></blockquote><p><strong>证明</strong>：当我们向堆中加入元素时要遵循以下规则：</p><ul><li>如果 $num≤top$，我们就将其加入<code>small</code> 中.</li><li>如果 $num&gt;top$，我们就将其加入 <code>large</code> 中</li></ul><p>列举所有情况，就可以得到推论2.<br>由推论2我们可以设计<code>insert(int num)</code>函数：对于第一种情况，我们将<code>small</code> 的堆顶元素放入<code>large</code>；对于第二种情况，我们将<code>large</code> 的堆顶元素放入<code>small</code></p><blockquote><p><strong>事实</strong>： 优先队列不支持移出非堆顶元素的操作。</p></blockquote><p>因此我们需要使用<strong>延迟删除</strong>来解决移除元素的操作。<strong>延迟删除</strong>核心思想就是：记录要删除的元素，而不是真正的删除，当该元素出现在堆顶时再进行删除。<br>我们使用哈希表<code>delayed</code>来实现延迟删除，键值对<code>(num, cnt)</code>表示元素<code>num</code>要被删除<code>cnt</code>次。我们设计函数<code>prune(T&amp; heap)</code>实现该操作。当我们加入或者移除元素时，由于堆顶元素有可能改变因此我们需要调用<code>prune(T&amp; heap)</code>保证堆顶元素是不需要被删除的。<br>具体操作如下：<br>对于<code>insert(int num)</code>，我们进行一定的修改：</p><ul><li>当两个堆元素个数符合要求时，我们无需进行多余操作</li><li><code>small</code>元素比<code>large</code>多2个时，我们将<code>small</code> 的堆顶元素放入<code>large</code>，此时<code>small</code>新的堆顶元素是可能需要被删除的，因此调用<code>prune(T&amp; heap)</code>。</li><li> <code>small</code>元素比<code>large</code>少1个时，我们将<code>large</code> 的堆顶元素放入<code>small</code>，此时<code>large</code>新的堆顶元素是可能需要被删除的，因此调用<code>prune(T&amp; heap)</code>。</li></ul><p>对于删除函数<code>erase(int num)</code>，我们将<code>delayed</code>中<code>num</code>的键值<code>cnt</code>加一即可。因为删除元素之后，两个堆的元素数有可能会不符合要求，因此需要进行类似<code>insert(int num)</code>中的操作。<br>综上，我们可以写出以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualHeap</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; large;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; delayed;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> smallCount, largeCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prune</span><span class="params">(T&amp; heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heap.top();</span><br><span class="line">            <span class="keyword">if</span> (delayed.count(num)) &#123;</span><br><span class="line">                <span class="comment">// 延迟删除队列中有堆顶元素</span></span><br><span class="line">                --delayed[num];</span><br><span class="line">                <span class="keyword">if</span> (!delayed[num]) &#123;</span><br><span class="line">                    delayed.erase(num);</span><br><span class="line">                &#125;</span><br><span class="line">                heap.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallCount &gt; largeCount + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// small比large元素多2个</span></span><br><span class="line">            large.push(small.top());</span><br><span class="line">            small.pop();</span><br><span class="line">            --smallCount;</span><br><span class="line">            ++largeCount;</span><br><span class="line">            <span class="comment">// 因为small堆顶改变，需要检查新堆顶是否可以删除</span></span><br><span class="line">            prune(small);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallCount &lt; largeCount) &#123;</span><br><span class="line">            <span class="comment">// large比small元素多1个</span></span><br><span class="line">            small.push(large.top());</span><br><span class="line">            large.pop();</span><br><span class="line">            ++smallCount;</span><br><span class="line">            --largeCount;</span><br><span class="line">            <span class="comment">// 与上面同理</span></span><br><span class="line">            prune(large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    DualHeap(<span class="keyword">int</span> a) : k(a), smallCount(<span class="number">0</span>), largeCount(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (small.empty() || num &lt;= small.top()) &#123;</span><br><span class="line">            small.push(num);</span><br><span class="line">            ++smallCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large.push(num);</span><br><span class="line">            ++largeCount;</span><br><span class="line">        &#125;</span><br><span class="line">        modify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        ++delayed[num];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= small.top()) &#123;</span><br><span class="line">            --smallCount;</span><br><span class="line">            <span class="keyword">if</span> (num == small.top()) &#123;</span><br><span class="line">                prune(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --largeCount;</span><br><span class="line">            <span class="keyword">if</span> (num == large.top()) &#123;</span><br><span class="line">                prune(large);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &amp; <span class="number">1</span> ? small.top() : ((<span class="keyword">double</span>)small.top() + large.top()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">DualHeap <span class="title">dh</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            dh.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret = &#123;dh.getMedian()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            dh.insert(nums[i]);</span><br><span class="line">            dh.erase(nums[i - k]);</span><br><span class="line">            ret.push_back(dh.getMedian());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;滑动窗口中位数&quot;&gt;&lt;a href=&quot;#滑动窗口中位数&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口中位数&quot;&gt;&lt;/a&gt;滑动窗口中位数&lt;/h2&gt;&lt;p&gt;中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="困难" scheme="https://www.shuocloud.top/categories/LeetCode/%E5%9B%B0%E9%9A%BE/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="哈希表" scheme="https://www.shuocloud.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="Hash" scheme="https://www.shuocloud.top/tags/Hash/"/>
    
    <category term="滑动窗口" scheme="https://www.shuocloud.top/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="Sliding Window" scheme="https://www.shuocloud.top/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>明日方舟拜年纪2021【皎星示岁】</title>
    <link href="https://www.shuocloud.top/2021/02/02/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E6%8B%9C%E5%B9%B4%E7%BA%AA2021%E3%80%90%E7%9A%8E%E6%98%9F%E7%A4%BA%E5%B2%81%E3%80%91/"/>
    <id>https://www.shuocloud.top/2021/02/02/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E6%8B%9C%E5%B9%B4%E7%BA%AA2021%E3%80%90%E7%9A%8E%E6%98%9F%E7%A4%BA%E5%B2%81%E3%80%91/</id>
    <published>2021-02-02T12:56:28.000Z</published>
    <updated>2021-02-07T13:03:35.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="明日方舟拜年纪2021【皎星示岁】"><a href="#明日方舟拜年纪2021【皎星示岁】" class="headerlink" title="明日方舟拜年纪2021【皎星示岁】"></a>明日方舟拜年纪2021【皎星示岁】</h2><p>看完方舟拜年纪的直播，有被震撼到。</p><a id="more"></a><p>此次拜年纪是同人作者和up主们自发举办的，我一开始就觉得差不了，但是没想到会如此之好。</p><p>方舟从开服到现在经历了太多，一开始由于产能低加上一些骚操作，导致节奏一直很大，不过随着产能的提高和运营的成熟，方舟区的相关讨论一直非常和谐，这是很罕见的。我记得有一次由于服务器的原因导致明日方舟等多款游戏无法登陆，然而各大官方的公告的评论区却大不相同，有骂ch的也有正经讨论游戏的，最让我印象深刻的还是舟游的评论区，这里是最和谐的，当时的热评第一是一句“半夜维护辛苦了”，这在其他任何评论区都无法看到的。</p><p>扯远了，下面是正片链接！</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=971418826&bvid=BV1Gp4y1s79x&cid=291683530&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>直播的时候海猫还打了36888元，然后拜年纪结尾合唱damedane直接背刺哈哈哈哈，</p><p>再欣赏一遍方舟版难忘今宵</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=971454479&bvid=BV1sp4y1s7Vw&cid=291692021&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>最后祝希望我夕池子没事。</p><hr><p>2-7日更</p><p>夕池子出事了，280发没有嵯峨。</p><img src="https://coding-net-production-file-ci.codehub.cn/27a0b260-6938-11eb-a5f9-db50e9ab0548.jpg?sign=Asme76dricJ3cVzd6OJUPf1chSdhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNjEyOTEzNjc1JnQ9MTYxMjY5NzY3NSZyPTg3MTUzMDgwJmY9LzI3YTBiMjYwLTY5MzgtMTFlYi1hNWY5LWRiNTBlOWFiMDU0OC5qcGcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==" width="50%"><img src="https://coding-net-production-file-ci.codehub.cn/27a71b00-6938-11eb-a5f9-db50e9ab0548.jpg?sign=bGn7PYE1ARdDhW2ddcZysqPq7MlhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNjEyOTEzNzEyJnQ9MTYxMjY5NzcxMiZyPTc3NDUwODA2JmY9LzI3YTcxYjAwLTY5MzgtMTFlYi1hNWY5LWRiNTBlOWFiMDU0OC5qcGcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==" width="50%"><img src="https://coding-net-production-file-ci.codehub.cn/27abaee0-6938-11eb-a5f9-db50e9ab0548.png?sign=OgT8l2MrgIQZGwCNhU1RgK6AqMJhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNjEyOTEzODYzJnQ9MTYxMjY5Nzg2MyZyPTUwODA4MjgmZj0vMjdhYmFlZTAtNjkzOC0xMWViLWE1ZjktZGI1MGU5YWIwNTQ4LnBuZyZiPWNvZGluZy1uZXQtcHJvZHVjdGlvbi1maWxl"><img src="https://coding-net-production-file-ci.codehub.cn/27a6f3f0-6938-11eb-a5f9-db50e9ab0548.png?sign=Hz0EIPsT6zfhk4hrU6Pr4lOX9sxhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNjEyOTEzODg1JnQ9MTYxMjY5Nzg4NSZyPTI0MjA4NDc1JmY9LzI3YTZmM2YwLTY5MzgtMTFlYi1hNWY5LWRiNTBlOWFiMDU0OC5wbmcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;明日方舟拜年纪2021【皎星示岁】&quot;&gt;&lt;a href=&quot;#明日方舟拜年纪2021【皎星示岁】&quot; class=&quot;headerlink&quot; title=&quot;明日方舟拜年纪2021【皎星示岁】&quot;&gt;&lt;/a&gt;明日方舟拜年纪2021【皎星示岁】&lt;/h2&gt;&lt;p&gt;看完方舟拜年纪的直播，有被震撼到。&lt;/p&gt;</summary>
    
    
    
    <category term="个人动态" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="明日方舟" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F/"/>
    
    
    <category term="日常谈" scheme="https://www.shuocloud.top/tags/%E6%97%A5%E5%B8%B8%E8%B0%88/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-888.Fair Candy Swap（公平的糖果棒交换）</title>
    <link href="https://www.shuocloud.top/2021/02/01/LeetCode-888-Fair-Candy-Swap%EF%BC%88%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2021/02/01/LeetCode-888-Fair-Candy-Swap%EF%BC%88%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2%EF%BC%89/</id>
    <published>2021-02-01T05:11:54.000Z</published>
    <updated>2021-02-01T07:50:57.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平的糖果棒交换"><a href="#公平的糖果棒交换" class="headerlink" title="公平的糖果棒交换"></a>公平的糖果棒交换</h2><p><strong>每日一题</strong></p><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。<br>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）<br>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是鲍勃必须交换的糖果棒的大小。</p><a id="more"></a><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。<br><strong>示例 1：</strong></p><blockquote><p><strong>输入</strong>：A = [1,1], B = [2,2]<br><strong>输出</strong>：[1,2]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入</strong>：A = [1,2], B = [2,3]<br><strong>输出</strong>：[1,2]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入</strong>：A = [2], B = [1,3]<br><strong>输出</strong>：[2,3]</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入</strong>：A = [1,2,5], B = [2,4]<br><strong>输出</strong>：[5,4]</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= B.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 100000</code></li><li><code>1 &lt;= B[i] &lt;= 100000</code></li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在</li></ol><h2 id="Fair-Candy-Swap"><a href="#Fair-Candy-Swap" class="headerlink" title="Fair Candy Swap"></a>Fair Candy Swap</h2><p>Alice and Bob have candy bars of different sizes: <code>A[i]</code> is the size of the <code>i</code>-th bar of candy that Alice has, and <code>B[j]</code> is the size of the <code>j</code>-th bar of candy that Bob has.<br>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)<br>Return an integer array ans where <code>ans[0]</code> is the size of the candy bar that Alice must exchange, and <code>ans[1]</code> is the size of the candy bar that Bob must exchange.<br>If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.<br><strong>Example 1:</strong></p><blockquote><p>Input: A = [1,1], B = [2,2]<br>Output: [1,2]</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: A = [1,2], B = [2,3]<br>Output: [1,2]</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: A = [2], B = [1,3]<br>Output: [2,3]</p></blockquote><p><strong>Example 4:</strong></p><blockquote><p>Input: A = [1,2,5], B = [2,4]<br>Output: [5,4]</p></blockquote><p><strong>Note:</strong></p><ul><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= B.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 100000</code></li><li><code>1 &lt;= B[i] &lt;= 100000</code></li><li>It is guaranteed that Alice and Bob have different total amounts of candy.</li><li>It is guaranteed there exists an answer.</li></ul><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>方法一：哈希表</strong><br>设爱丽丝和鲍勃的糖果总数分别为$sumA$和$sumB$，交换的糖果数分别为$xA$和$xB$，由此我们有等式：<br>$$sumA-xA+xB=sumB+xA-xB$$<br>化简可得：<br>$$xA=xB+\frac{sumA-sumB}{2}$$<br>因此对于<br>$$\forall xB\in B,\exists xA\in A,s.t.\ xA=xB+\frac{sumA-sumB}{2}$$<br>那么<code>&#123;xA, xB&#125;</code>就是一组可行解。<br>为了加快查找速度，我们使用哈希表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fairCandySwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumA = accumulate(A.begin(), A.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sumB = accumulate(B.begin(), B.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> delta = (sumA - sumB) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hashA</span><span class="params">(A.begin(), A.end())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//因为答案一定存在，所以这样写也不会出错</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xB: B)&#123;</span><br><span class="line">    <span class="keyword">int</span> xA = xB + delta;</span><br><span class="line">    <span class="keyword">if</span>(hashA.count(xA))&#123;<span class="comment">//能找到解</span></span><br><span class="line">    ret[<span class="number">0</span>] = xA;</span><br><span class="line">    ret[<span class="number">1</span>] = xB;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针</strong><br>首先将两个数组升序排序。<br>设$$\Delta=\frac{sumA-sumB}{2}$$<br>根据上面的分析，我们知道有以下等式<br>$$xA-xB=\Delta$$<br>设<code>i</code>，<code>j</code>为两个指针，同时设$k=A[i]-B[j]$我们有以下三种情况：</p><ol><li><code>k==delta</code>，直接返回答案</li><li><code>k&gt;delta</code>，增大<code>j</code></li><li><code>k&lt;delta</code>，增大<code>i</code></li></ol><p>由此，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fairCandySwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumA = accumulate(A.begin(), A.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sumB = accumulate(B.begin(), B.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> delta = (sumA - sumB) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        sort(B.begin(), B.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.size() &amp;&amp; j &lt; B.size()) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = A[i] - B[j];</span><br><span class="line">            <span class="keyword">if</span> (k == delta) &#123;</span><br><span class="line">                ret[<span class="number">0</span>] = A[i];</span><br><span class="line">                ret[<span class="number">1</span>] = B[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; delta) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;公平的糖果棒交换&quot;&gt;&lt;a href=&quot;#公平的糖果棒交换&quot; class=&quot;headerlink&quot; title=&quot;公平的糖果棒交换&quot;&gt;&lt;/a&gt;公平的糖果棒交换&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;每日一题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;爱丽丝和鲍勃有不同大小的糖果棒：&lt;code&gt;A[i]&lt;/code&gt; 是爱丽丝拥有的第 &lt;code&gt;i&lt;/code&gt; 根糖果棒的大小，&lt;code&gt;B[j]&lt;/code&gt; 是鲍勃拥有的第 &lt;code&gt;j&lt;/code&gt; 根糖果棒的大小。&lt;br&gt;因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）&lt;br&gt;返回一个整数数组 &lt;code&gt;ans&lt;/code&gt;，其中 &lt;code&gt;ans[0]&lt;/code&gt; 是爱丽丝必须交换的糖果棒的大小，&lt;code&gt;ans[1]&lt;/code&gt; 是鲍勃必须交换的糖果棒的大小。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
    <category term="哈希表" scheme="https://www.shuocloud.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://www.shuocloud.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="Two Pointers" scheme="https://www.shuocloud.top/tags/Two-Pointers/"/>
    
    <category term="Hash" scheme="https://www.shuocloud.top/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-839. Similar String Groups（相似字符串组）</title>
    <link href="https://www.shuocloud.top/2021/01/31/LeetCode-839-Similar-String-Groups%EF%BC%88%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2021/01/31/LeetCode-839-Similar-String-Groups%EF%BC%88%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%EF%BC%89/</id>
    <published>2021-01-31T11:50:31.000Z</published>
    <updated>2021-02-01T04:50:34.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相似字符串组"><a href="#相似字符串组" class="headerlink" title="相似字符串组"></a>相似字符串组</h2><p><strong>每日一题</strong></p><p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 <code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><a id="more"></a><p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p><p>总之，它们通过相似性形成了两个关联组：<code>&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125;</code> 和 <code>&#123;&quot;star&quot;&#125;</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入</strong>：strs = [“tars”,”rats”,”arts”,”star”]<br><strong>输出</strong>：2</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入</strong>：strs = [“omv”,”ovm”]<br><strong>输出</strong>：1</p></blockquote><p><strong>提示：</strong></p><ol><li><code>1 &lt;= strs.length &lt;= 100</code></li><li><code>1 &lt;= strs[i].length &lt;= 1000</code></li><li><code>sum(strs[i].length) &lt;= 2 * 104</code></li><li><code>strs[i]</code> 只包含小写字母。</li><li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li></ol><p><strong>备注：</strong><br>字母异位词（anagram），一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。</p><h2 id="Similar-String-Groups"><a href="#Similar-String-Groups" class="headerlink" title="Similar String Groups"></a>Similar String Groups</h2><p>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>. Also two strings <code>X</code> and <code>Y</code> are similar if they are equal.</p><p>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to <code>&quot;tars&quot;</code>, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p><p>Together, these form two connected groups by similarity: <code>&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125;</code> and <code>&#123;&quot;star&quot;&#125;</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p><p>We are given a list strs of strings where every string in strs is an anagram of every other string in strs. How many groups are there?<br><strong>Example 1:</strong></p><blockquote><p><strong>Input</strong>: strs = [“tars”,”rats”,”arts”,”star”]<br><strong>Output</strong>: 2</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input</strong>: strs = [“omv”,”ovm”]<br><strong>Output</strong>: 1</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 100</code></li><li><code>1 &lt;= strs[i].length &lt;= 1000</code></li><li><code>sum(strs[i].length) &lt;= 2 * 104</code></li><li><code>strs[i]</code> consists of lowercase letters only.</li><li>All words in <code>strs</code> have the same length and are anagrams of each other.</li></ul><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>并查集</strong><br>相似字符串的意思是：通过交换字符串<code>str1</code>某两个字母的位置，使得<code>str1</code>与<code>str2</code>相同。注意，这里<strong>只能交换两个字母的位置</strong>。<br><strong>具体做法是，将每个字符串当做图的一个节点，当两个字符串相似时，就将两个结点之间画一条边，如此，相似的字符串组就形成了一个连通图，连通区域的个数就是我们想要的答案。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        n = strs.size();</span><br><span class="line">        <span class="function">UnionFind <span class="title">unionFind</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isSimilar(strs[i], strs[j])) &#123;</span><br><span class="line">                    unionFind.connect(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unionFind.getRegions();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i] != str2[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">2</span> || count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">       <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> regions;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> n) : parent(n), regions(n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> root(x) == root(y); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected(p, q)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[root(p)] = root(q);</span><br><span class="line">            regions--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getRegions</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> regions; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;相似字符串组&quot;&gt;&lt;a href=&quot;#相似字符串组&quot; class=&quot;headerlink&quot; title=&quot;相似字符串组&quot;&gt;&lt;/a&gt;相似字符串组&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;每日一题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果交换字符串 &lt;code&gt;X&lt;/code&gt; 中的两个不同位置的字母，使得它和字符串 &lt;code&gt;Y&lt;/code&gt; 相等，那么称 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="困难" scheme="https://www.shuocloud.top/categories/LeetCode/%E5%9B%B0%E9%9A%BE/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="Depth-first Search" scheme="https://www.shuocloud.top/tags/Depth-first-Search/"/>
    
    <category term="Union Find" scheme="https://www.shuocloud.top/tags/Union-Find/"/>
    
    <category term="深度优先搜索" scheme="https://www.shuocloud.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="并查集" scheme="https://www.shuocloud.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="图" scheme="https://www.shuocloud.top/tags/%E5%9B%BE/"/>
    
    <category term="Graph" scheme="https://www.shuocloud.top/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-778.Swim in Rising Water（水位上升的泳池中游泳）</title>
    <link href="https://www.shuocloud.top/2021/01/30/LeetCode-778-Swim-in-Rising-Water%EF%BC%88%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2021/01/30/LeetCode-778-Swim-in-Rising-Water%EF%BC%88%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3%EF%BC%89/</id>
    <published>2021-01-30T11:22:15.000Z</published>
    <updated>2021-02-01T04:50:39.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水位上升的泳池中游泳"><a href="#水位上升的泳池中游泳" class="headerlink" title="水位上升的泳池中游泳"></a>水位上升的泳池中游泳</h2><p><strong>每日一题</strong></p><p>在一个 N x N 的坐标方格 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示在位置 <code>(i,j)</code> 的平台高度。</p><p>现在开始下雨了。当时间为 <code>t</code> 时，此时雨水导致水池中任意位置的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p><p>你从坐标方格的左上平台 <code>(0，0)</code> 出发。最少耗时多久你才能到达坐标方格的右下平台 <code>(N-1, N-1)</code>？</p><a id="more"></a><p><strong>示例1</strong></p><blockquote><p><strong>输入</strong>: [[0,2],[1,3]]<br><strong>输出</strong>: 3<br><strong>解释</strong>:<br>时间为0时，你位于坐标方格的位置为 (0, 0)。<br>此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。<br>等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</p></blockquote><p><strong>示例2</strong></p><blockquote><p><strong>输入</strong>: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br><strong>输出</strong>: 16<br><strong>解释</strong>:<br>0  1  2  3  4<br>24 23 22 21  5<br>12 13 14 15 16<br>11 17 18 19 20<br>10  9  8  7  6<br>最终的路线用加粗进行了标记。<br>我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的</p></blockquote><p><strong>提示</strong></p><ol><li><code>2 &lt;= N &lt;= 50</code></li><li><code>grid[i][j]</code> 是 <code>[0, ..., N*N - 1]</code> 的排列</li></ol><h2 id="Swim-in-Rising-Water"><a href="#Swim-in-Rising-Water" class="headerlink" title="Swim in Rising Water"></a>Swim in Rising Water</h2><p>On an <code>N x N</code> grid, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i,j)</code>.</p><p>Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input</strong>: [[0,2],[1,3]]<br><strong>Output</strong>: 3<br><strong>Explanation</strong>:<br>At time 0, you are in grid location (0, 0).<br>You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.<br>You cannot reach point (1, 1) until time 3.<br>When the depth of water is 3, we can swim anywhere inside the grid.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input</strong>: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br><strong>Output</strong>: 16<br><strong>Explanation</strong>:<br>0  1  2  3  4<br>24 23 22 21  5<br>12 13 14 15 16<br>11 17 18 19 20<br>10  9  8  7  6<br>The final route is marked in bold.<br>We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</p></blockquote><p><strong>Note:</strong></p><ol><li><code>2 &lt;= N &lt;= 50</code></li><li><code>grid[i][j]</code> is a permutation of <code>[0, ..., N*N - 1]</code>.</li></ol><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>方法一：并查集</strong><br>这个方法应该是比较容易想到和实现的了。<br>我们模拟下雨的过程，在时刻<code>t</code>，对于高度为<code>t</code>单元格，我们检查当前时刻是否能够游到相邻的单元格内（即高度小于等于当前单元格的高度），然后将能够到达的单元格合并。当终点和起点连通时，就是我们要求的时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> directions[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> len = n * n;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(len)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">index[grid[i][j]] = getIndex(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionFind <span class="title">unionFind</span><span class="params">(len)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> x = index[i]/n;</span><br><span class="line"><span class="keyword">int</span> y = index[i]%n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> direction:directions)&#123;</span><br><span class="line"><span class="keyword">int</span> newX = x + direction[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> newY = y + direction[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(isIn(newX,newY) &amp;&amp; grid[newX][newY] &lt;= i)&#123;</span><br><span class="line">unionFind.connect(index[i], getIndex(newX,newY));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(unionFind.isConnected(<span class="number">0</span>,len<span class="number">-1</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * n + y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n; &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">       <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span>:</span><br><span class="line">        UnionFind(<span class="keyword">int</span> n) : parent(n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> root(x) == root(y); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected(p, q)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[root(p)] = root(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外本题还有搜索算法和Dijkstra算法等方法，之后更新…</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;水位上升的泳池中游泳&quot;&gt;&lt;a href=&quot;#水位上升的泳池中游泳&quot; class=&quot;headerlink&quot; title=&quot;水位上升的泳池中游泳&quot;&gt;&lt;/a&gt;水位上升的泳池中游泳&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;每日一题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个 N x N 的坐标方格 &lt;code&gt;grid&lt;/code&gt; 中，每一个方格的值 &lt;code&gt;grid[i][j]&lt;/code&gt; 表示在位置 &lt;code&gt;(i,j)&lt;/code&gt; 的平台高度。&lt;/p&gt;
&lt;p&gt;现在开始下雨了。当时间为 &lt;code&gt;t&lt;/code&gt; 时，此时雨水导致水池中任意位置的水位为 &lt;code&gt;t&lt;/code&gt; 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。&lt;/p&gt;
&lt;p&gt;你从坐标方格的左上平台 &lt;code&gt;(0，0)&lt;/code&gt; 出发。最少耗时多久你才能到达坐标方格的右下平台 &lt;code&gt;(N-1, N-1)&lt;/code&gt;？&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="困难" scheme="https://www.shuocloud.top/categories/LeetCode/%E5%9B%B0%E9%9A%BE/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="二分查找" scheme="https://www.shuocloud.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="Binary Search" scheme="https://www.shuocloud.top/tags/Binary-Search/"/>
    
    <category term="Heap" scheme="https://www.shuocloud.top/tags/Heap/"/>
    
    <category term="Depth-first Search" scheme="https://www.shuocloud.top/tags/Depth-first-Search/"/>
    
    <category term="Union Find" scheme="https://www.shuocloud.top/tags/Union-Find/"/>
    
    <category term="堆" scheme="https://www.shuocloud.top/tags/%E5%A0%86/"/>
    
    <category term="深度优先搜索" scheme="https://www.shuocloud.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="并查集" scheme="https://www.shuocloud.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>《崩坏3》动画短片「渡尘」</title>
    <link href="https://www.shuocloud.top/2021/01/29/%E3%80%8A%E5%B4%A9%E5%9D%8F3%E3%80%8B%E5%8A%A8%E7%94%BB%E7%9F%AD%E7%89%87%E3%80%8C%E6%B8%A1%E5%B0%98%E3%80%8D/"/>
    <id>https://www.shuocloud.top/2021/01/29/%E3%80%8A%E5%B4%A9%E5%9D%8F3%E3%80%8B%E5%8A%A8%E7%94%BB%E7%9F%AD%E7%89%87%E3%80%8C%E6%B8%A1%E5%B0%98%E3%80%8D/</id>
    <published>2021-01-29T06:42:48.000Z</published>
    <updated>2021-01-29T07:09:29.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《崩坏3》动画短片「渡尘」"><a href="#《崩坏3》动画短片「渡尘」" class="headerlink" title="《崩坏3》动画短片「渡尘」"></a>《崩坏3》动画短片「渡尘」</h2><p><strong>世间之纷扰，早已麻木</strong><br><strong>珍重之羁绊，尽皆离散</strong><br><strong>千年之坚守，只为拯救苍生</strong></p><a id="more"></a><p>是糖是糖！</p><p>一路走来，符华真的太不容易了，希望这次是阿符的新生。</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=501440303&bvid=BV1jN411o7zS&cid=289175447&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p>4:47的上仙绝美！</p><p>5:32开始真的要哭出来了</p><p><strong>日月沉浮 ，沧海桑田</strong></p><p><strong>历尽了离别，习惯了绝望</strong></p><p><strong>不知时间为何物</strong></p><p><strong>亡命于无尽的轮回</strong></p><p><strong>只为——</strong></p><p><strong>使命！</strong></p><p><strong>欢迎回家，班长！</strong></p><p>也恭喜短片登顶！</p><p>另外这次「Rubia」——《崩坏3》印象曲（演唱者：周深）也超赞，</p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=543949325&bvid=BV1Yv4y1o7dw&cid=289220053&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;《崩坏3》动画短片「渡尘」&quot;&gt;&lt;a href=&quot;#《崩坏3》动画短片「渡尘」&quot; class=&quot;headerlink&quot; title=&quot;《崩坏3》动画短片「渡尘」&quot;&gt;&lt;/a&gt;《崩坏3》动画短片「渡尘」&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;世间之纷扰，早已麻木&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;珍重之羁绊，尽皆离散&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;千年之坚守，只为拯救苍生&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="个人动态" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="崩坏三" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/%E5%B4%A9%E5%9D%8F%E4%B8%89/"/>
    
    
    <category term="日常谈" scheme="https://www.shuocloud.top/tags/%E6%97%A5%E5%B8%B8%E8%B0%88/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>《明日方舟》SideStory「画中人」活动宣传PV</title>
    <link href="https://www.shuocloud.top/2021/01/28/%E3%80%8A%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E3%80%8BSideStory%E3%80%8C%E7%94%BB%E4%B8%AD%E4%BA%BA%E3%80%8D%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0PV/"/>
    <id>https://www.shuocloud.top/2021/01/28/%E3%80%8A%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F%E3%80%8BSideStory%E3%80%8C%E7%94%BB%E4%B8%AD%E4%BA%BA%E3%80%8D%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0PV/</id>
    <published>2021-01-28T03:20:54.000Z</published>
    <updated>2021-01-31T15:08:16.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《明日方舟》SideStory「画中人」活动宣传PV"><a href="#《明日方舟》SideStory「画中人」活动宣传PV" class="headerlink" title="《明日方舟》SideStory「画中人」活动宣传PV"></a>《明日方舟》SideStory「画中人」活动宣传PV</h2><p>鹰角终于发饼啦！</p><a id="more"></a><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?aid=543761542&bvid=BV1jv4y1f7jH&cid=288439321&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><p><strong>话术，那古往今来</strong></p><p><strong>多少文人雅士，喜画爱画</strong></p><p><strong>大炎江山万里，风光无限</strong></p><p><strong>奇人妙事，数不胜数</strong></p><p><strong>却要说有一人，一笔涂尽人间事</strong></p><p><strong>见过沧海桑田，望过白日飞升</strong></p><p><strong>走过拙山枯水，笑过月隐晦明</strong></p><p><strong>列位看官可知</strong></p><p><strong>此人姓甚名谁，又来自何方</strong></p><p>本期重点：</p><p>绝赞的国风</p><p>Zc乌有说</p><p>井夕夕</p><p>旗袍年</p><p>老陈懂个锤子旗袍</p><p>一介车夫——吽</p><p>老鲤，我治死个人.jpg</p><p>水母皮肤</p><h3 id="旗袍——年"><a href="#旗袍——年" class="headerlink" title="旗袍——年"></a>旗袍——年</h3><blockquote><p>年的旗袍皮肤真的太香了，年本身就是超级大美人，双臂以及大腿处的鲜红花纹已经将年的身体凸显得异常白嫩。这回皮肤又用了白色为主色调，加以红色花纹点缀的优雅旗袍，简直就是为了年特意量身定制的绝美衣裳。（本来就是.jpg）<br>另外，稍显“桀骜不驯”的动作不会让优雅的服饰局限住年本身的性格，左腿穿着白色高跟鞋轻轻点地，又恰到好处的展现了年极佳的身段。<br>同时，黑扇朝唇下轻轻一点，整个人的神态动作浑然天成，悄无声息地体现其特有的慵懒气质。再加上年的大尾巴从椅子下方穿过翘起，更是又给其增添了几分色气。有一说一，真的很有年这个角色的独特韵味。<br>背景方面，为了不让整个画面被白色或红色冲的太扎眼，巧妙使用了暗色调的现代房间，在保留了高格调和神秘感的同时，凸显了坐在前方的年本人，并与其他皮肤的风格达成了统一。背后那不知是雕塑还是化作的巨大龙头更好像是要冲出平面，阳面与阴面划分自然，张力十足。<br>废话说了这么多，总结下来就一句。<br>这皮肤，我买爆！</p></blockquote><blockquote><p>一身素白的旗袍配上玩世不恭的气质，纯洁的圣兽配上大胆的动作<br>清纯与火热交融促进，保守与开放相得益彰<br>一双玲珑玉腿舒展的有如白玉兰枝<br>微微翘起的一玉足更是勾起无数内心的悸动一把黑扇点下颔，纤纤五指如削葱。<br>红臂更衬衣袍白，琉璃眼眸送秋波。<br>白尾勾焰挑欲火，朱唇皓齿媚不尽。<br>风起扇开半遮面，未语先有郎妾意。<br>颦笑莲步逶迤近，软玉入怀情入心。<br>大炎万里山河壮，不若美人配才郎。<br>正是<br>上得厅堂下得厨房，玲珑有致风情万种，端的是素白好贤妻<br>剑劈锡灼盾展铁御，炉起融金铸铜锻银，好一个威风女将军</p><p>年酱，永远的单推</p></blockquote><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><blockquote><p>开场的笛声娓娓道来，配合背景的水墨画一瞬间将人置入仙境，随后的古筝虽为辅，但却令人沉浸在她的温柔中无法自拔，使人忍不住闭上眼去感受那澄澈如露的绝妙音律。突然，众乐器一同奏起，我仿佛听到了东方神龙的吼声，睁眼，我看到那威严的神龙蜿蜒盘旋与崇山峻岭之间，那吼声响彻大地，顿时百鸟争鸣，百花齐放，衬托出东方巨龙神圣气魄。此时的我正疑惑自己所处莫非真是人们所向往的桃源乡时，突然狂风呼啸，晨雾被驱散，而后显现出这“桃源乡”的本貌：那巍峨的山其实是城，大气磅礴的辉煌古城，那花鸟，则是人。百鸟争鸣，是欢声笑语，引吭高歌的人们，百花齐放，是不同民族的人汇聚在一起，绽放出的百种不同样貌。神龙腾空而起，翱翔与这九州大地之上，守护着人们。如果这世上真有桃源乡，那这里便是了吧。</p><p>这次简直高潮迭起一波三折！先是清雅的音乐配合一幅幅晕开的画面将观众期待值拉满，在逐渐加速的节奏中干员依次登场，两六星的出场是音乐的第一次高潮，接一小段水波粼粼般的间奏给活动主界面一个结束亮相，本以为pv就要平稳荡开了，突然高潮再起，四套时装一齐亮相，更激烈更欢快于第一段的音乐将观众情绪推向下一个高峰，随后伴随着活动其余内容的依次展示音乐强中渐强，余音绕梁回味无穷～</p></blockquote><h3 id="有关嵯峨"><a href="#有关嵯峨" class="headerlink" title="有关嵯峨"></a>有关嵯峨</h3><p>公元804年，唐德宗李适(kuo, 第四声)驾崩，葬嵯峨山崇陵(今陕西泾阳) 。日遣唐使给德宗皇帝送灵观礼，到了嵯峨山后见到了德宗的崇陵，觉得山势巍峨，帝陵宏伟，不禁感叹:真乃大唐气象!回国后面见平城天皇，把大唐吹得那是天花乱坠,说他在天朝见到了万年难遇的神造之山!并绘制了一幅莲花形的嵯峨山图。</p><p>太子神野听了以后十分神往，即位之后直接将自己的尊号叫做“嵯峨天皇”，并于京都郊外营建离宫,起名“嵯峨院”。</p><p>嵯峨天皇在位期间大力推行唐化，从礼仪、服饰、殿堂建筑到生活方式都模仿大唐风度。同时，他还迷恋汉学，在诗赋、书法、音律方面都有相当造诣，与空海、橘逸势并称为“平安三笔”。公元823年，嵯峨天皇退位成为上皇，即日移驾京都郊外的嵯峨院，并长住于此，最终崩于嵯峨院。嵯峨院周围的原野即被称作“嵯峨野”，所在的山峰亦被命名为“嵯峨山”。嵯峨天皇驾崩后，遵照其遗愿埋葬于嵯峨山，称“嵯峨山上陵”。嵯峨天皇可谓是历史最知名的海外“唐吹”之一。</p><p>干员“嵯峨”的设定，或许就是东国的“遣炎使”，代表着崇拜炎国的意义。</p><p>ps：有关配音的是话题我不想多说了，是没别的刺可挑了才开的配音的团吧。文化自信可不是这么用的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;《明日方舟》SideStory「画中人」活动宣传PV&quot;&gt;&lt;a href=&quot;#《明日方舟》SideStory「画中人」活动宣传PV&quot; class=&quot;headerlink&quot; title=&quot;《明日方舟》SideStory「画中人」活动宣传PV&quot;&gt;&lt;/a&gt;《明日方舟》SideStory「画中人」活动宣传PV&lt;/h2&gt;&lt;p&gt;鹰角终于发饼啦！&lt;/p&gt;</summary>
    
    
    
    <category term="个人动态" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="明日方舟" scheme="https://www.shuocloud.top/categories/%E4%B8%AA%E4%BA%BA%E5%8A%A8%E6%80%81/%E6%B8%B8%E6%88%8F/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F/"/>
    
    
    <category term="日常谈" scheme="https://www.shuocloud.top/tags/%E6%97%A5%E5%B8%B8%E8%B0%88/"/>
    
    <category term="游戏" scheme="https://www.shuocloud.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-119. Pascal&#39;s Triangle II（杨辉三角 II）</title>
    <link href="https://www.shuocloud.top/2018/01/28/LeetCode-119-Pascal-s-Triangle-II%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/28/LeetCode-119-Pascal-s-Triangle-II%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II%EF%BC%89/</id>
    <published>2018-01-28T09:20:46.000Z</published>
    <updated>2021-02-01T04:50:53.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a>杨辉三角 II</h2><p>给定一个非负索引 <em>k</em>，其中 <em>k ≤ 33</em>，返回杨辉三角的第 <em>k</em> 行。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/2019021318314726.gif" alt="在这里插入图片描述"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:</p><blockquote><p>输入: 3<br>输出: [1,3,3,1]</p></blockquote><p><strong>进阶：</strong></p><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p><h2 id="Pascal’s-Triangle-II"><a href="#Pascal’s-Triangle-II" class="headerlink" title="Pascal’s Triangle II"></a>Pascal’s Triangle II</h2><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.<br><img src="https://img-blog.csdnimg.cn/20190213183722217.gif" alt="在这里插入图片描述"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>Example:</p><blockquote><p>Input: 3<br>Output: [1,3,3,1]</p></blockquote><p><strong>Follow up:</strong></p><p>Could you optimize your algorithm to use only O(k) extra space?</p><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>由<a href="https://ichen2000.com/2018/01/27/LeetCode-118-Pascal-s-Triangle%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89/"  target="_blank">第118题的题解</a>中的性质5：二项式 $(a+b)^n$ 的系数对应杨辉三角第 $n$ 行的每一个数。</p><p>同时我们知道<br>$$<br>\begin{align}<br>c^i_n&amp;=\frac{n!}{i!(n-i)!} \newline<br>c^{i+1}_n&amp;=\frac{n!}{(i+1)!(n-i-1)!}<br>\end{align}<br>$$<br>由(1)(2)得</p><p>$$c^{i+1}_n=\frac{n-i}{i+1}c^i_n$$</p><p>然后们就有如下解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++ i)</span><br><span class="line">            res[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)res[i - <span class="number">1</span>] * (rowIndex - i + <span class="number">1</span>) / i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;杨辉三角-II&quot;&gt;&lt;a href=&quot;#杨辉三角-II&quot; class=&quot;headerlink&quot; title=&quot;杨辉三角 II&quot;&gt;&lt;/a&gt;杨辉三角 II&lt;/h2&gt;&lt;p&gt;给定一个非负索引 &lt;em&gt;k&lt;/em&gt;，其中 &lt;em&gt;k ≤ 33&lt;/em&gt;，返回杨辉三角的第 &lt;em&gt;k&lt;/em&gt; 行。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-118. Pascal&#39;s Triangle（杨辉三角）</title>
    <link href="https://www.shuocloud.top/2018/01/27/LeetCode-118-Pascal-s-Triangle%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/27/LeetCode-118-Pascal-s-Triangle%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89/</id>
    <published>2018-01-27T04:24:45.000Z</published>
    <updated>2021-01-27T04:55:07.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>给定一个非负整数 <em>numRows</em>，生成杨辉三角的前 <em>numRows</em> 行。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20190213182724160.gif" alt="在这里插入图片描述"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>示例:</p><blockquote><p>输入: 5<br>输出:<br>[<br>       [1],<br>     [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p></blockquote><h2 id="Pascal’s-Triangle"><a href="#Pascal’s-Triangle" class="headerlink" title="Pascal’s Triangle"></a>Pascal’s Triangle</h2><p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br><img src="https://img-blog.csdnimg.cn/20190213182902277.gif" alt="在这里插入图片描述"><br>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>Example:</p><blockquote><p>Input: 5<br>Output:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>方法一</strong></p><p>在小学二年级学习组合数的时候，我们就知道杨辉三角能够表示二项式的系数，且有以下性质：</p><ol><li>对称性：首项和末项都为1</li><li>第 $n$ 行（从 $0$ 编号）有 $n+1$ 项，前 $n$ 行共有 $\frac{n(n+1)}{2}$ 个数。</li><li>第 $n$ 行第 $m$ 个数可以用组合数 $C^m_n$ 表示，且 $c^m_n=\frac{n!}{m!(n-m)!}$</li><li>每个数字等于其两肩上的数之和，这也是组合数的性质之一，即 $c_n^i=c_{n-1}^{i-1}+c_{n-1}^i$</li><li>二项式 $(a+b)^n$ 的系数对应杨辉三角第 $n$ 行的每一个数。</li></ol><p>由性质4我们可有解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i) &#123;</span><br><span class="line">            ret[i].resize(i + <span class="number">1</span>);</span><br><span class="line">            ret[i][<span class="number">0</span>] = ret[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                ret[i][j] = ret[i - <span class="number">1</span>][j] + ret[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：打表（不讲武德法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">21</span>, <span class="number">7</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">28</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">28</span>, <span class="number">8</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">36</span>, <span class="number">84</span>, <span class="number">126</span>, <span class="number">126</span>, <span class="number">84</span>, <span class="number">36</span>, <span class="number">9</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">45</span>, <span class="number">120</span>, <span class="number">210</span>, <span class="number">252</span>, <span class="number">210</span>, <span class="number">120</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">165</span>, <span class="number">330</span>, <span class="number">462</span>, <span class="number">462</span>, <span class="number">330</span>, <span class="number">165</span>, <span class="number">55</span>, <span class="number">11</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">12</span>, <span class="number">66</span>, <span class="number">220</span>, <span class="number">495</span>, <span class="number">792</span>, <span class="number">924</span>, <span class="number">792</span>, <span class="number">495</span>, <span class="number">220</span>, <span class="number">66</span>, <span class="number">12</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">13</span>, <span class="number">78</span>, <span class="number">286</span>, <span class="number">715</span>, <span class="number">1287</span>, <span class="number">1716</span>, <span class="number">1716</span>, <span class="number">1287</span>, <span class="number">715</span>, <span class="number">286</span>, <span class="number">78</span>, <span class="number">13</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">14</span>, <span class="number">91</span>, <span class="number">364</span>, <span class="number">1001</span>, <span class="number">2002</span>, <span class="number">3003</span>, <span class="number">3432</span>, <span class="number">3003</span>, <span class="number">2002</span>, <span class="number">1001</span>, <span class="number">364</span>, <span class="number">91</span>, <span class="number">14</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">15</span>, <span class="number">105</span>, <span class="number">455</span>, <span class="number">1365</span>, <span class="number">3003</span>, <span class="number">5005</span>, <span class="number">6435</span>, <span class="number">6435</span>, <span class="number">5005</span>, <span class="number">3003</span>, <span class="number">1365</span>, <span class="number">455</span>, <span class="number">105</span>, <span class="number">15</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">16</span>, <span class="number">120</span>, <span class="number">560</span>, <span class="number">1820</span>, <span class="number">4368</span>, <span class="number">8008</span>, <span class="number">11440</span>, <span class="number">12870</span>, <span class="number">11440</span>, <span class="number">8008</span>, <span class="number">4368</span>, <span class="number">1820</span>, <span class="number">560</span>, <span class="number">120</span>, <span class="number">16</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">17</span>, <span class="number">136</span>, <span class="number">680</span>, <span class="number">2380</span>, <span class="number">6188</span>, <span class="number">12376</span>, <span class="number">19448</span>, <span class="number">24310</span>, <span class="number">24310</span>, <span class="number">19448</span>, <span class="number">12376</span>, <span class="number">6188</span>, <span class="number">2380</span>, <span class="number">680</span>, <span class="number">136</span>, <span class="number">17</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">18</span>, <span class="number">153</span>, <span class="number">816</span>, <span class="number">3060</span>, <span class="number">8568</span>, <span class="number">18564</span>, <span class="number">31824</span>, <span class="number">43758</span>, <span class="number">48620</span>, <span class="number">43758</span>, <span class="number">31824</span>, <span class="number">18564</span>, <span class="number">8568</span>, <span class="number">3060</span>, <span class="number">816</span>, <span class="number">153</span>, <span class="number">18</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">19</span>, <span class="number">171</span>, <span class="number">969</span>, <span class="number">3876</span>, <span class="number">11628</span>, <span class="number">27132</span>, <span class="number">50388</span>, <span class="number">75582</span>, <span class="number">92378</span>, <span class="number">92378</span>, <span class="number">75582</span>, <span class="number">50388</span>, <span class="number">27132</span>, <span class="number">11628</span>, <span class="number">3876</span>, <span class="number">969</span>, <span class="number">171</span>, <span class="number">19</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">190</span>, <span class="number">1140</span>, <span class="number">4845</span>, <span class="number">15504</span>, <span class="number">38760</span>, <span class="number">77520</span>, <span class="number">125970</span>, <span class="number">167960</span>, <span class="number">184756</span>, <span class="number">167960</span>, <span class="number">125970</span>, <span class="number">77520</span>, <span class="number">38760</span>, <span class="number">15504</span>, <span class="number">4845</span>, <span class="number">1140</span>, <span class="number">190</span>, <span class="number">20</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">21</span>, <span class="number">210</span>, <span class="number">1330</span>, <span class="number">5985</span>, <span class="number">20349</span>, <span class="number">54264</span>, <span class="number">116280</span>, <span class="number">203490</span>, <span class="number">293930</span>, <span class="number">352716</span>, <span class="number">352716</span>, <span class="number">293930</span>, <span class="number">203490</span>, <span class="number">116280</span>, <span class="number">54264</span>, <span class="number">20349</span>, <span class="number">5985</span>, <span class="number">1330</span>, <span class="number">210</span>, <span class="number">21</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">22</span>, <span class="number">231</span>, <span class="number">1540</span>, <span class="number">7315</span>, <span class="number">26334</span>, <span class="number">74613</span>, <span class="number">170544</span>, <span class="number">319770</span>, <span class="number">497420</span>, <span class="number">646646</span>, <span class="number">705432</span>, <span class="number">646646</span>, <span class="number">497420</span>, <span class="number">319770</span>, <span class="number">170544</span>, <span class="number">74613</span>, <span class="number">26334</span>, <span class="number">7315</span>, <span class="number">1540</span>, <span class="number">231</span>, <span class="number">22</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">23</span>, <span class="number">253</span>, <span class="number">1771</span>, <span class="number">8855</span>, <span class="number">33649</span>, <span class="number">100947</span>, <span class="number">245157</span>, <span class="number">490314</span>, <span class="number">817190</span>, <span class="number">1144066</span>, <span class="number">1352078</span>, <span class="number">1352078</span>, <span class="number">1144066</span>, <span class="number">817190</span>, <span class="number">490314</span>, <span class="number">245157</span>, <span class="number">100947</span>, <span class="number">33649</span>, <span class="number">8855</span>, <span class="number">1771</span>, <span class="number">253</span>, <span class="number">23</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">24</span>, <span class="number">276</span>, <span class="number">2024</span>, <span class="number">10626</span>, <span class="number">42504</span>, <span class="number">134596</span>, <span class="number">346104</span>, <span class="number">735471</span>, <span class="number">1307504</span>, <span class="number">1961256</span>, <span class="number">2496144</span>, <span class="number">2704156</span>, <span class="number">2496144</span>, <span class="number">1961256</span>, <span class="number">1307504</span>, <span class="number">735471</span>, <span class="number">346104</span>, <span class="number">134596</span>, <span class="number">42504</span>, <span class="number">10626</span>, <span class="number">2024</span>, <span class="number">276</span>, <span class="number">24</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">25</span>, <span class="number">300</span>, <span class="number">2300</span>, <span class="number">12650</span>, <span class="number">53130</span>, <span class="number">177100</span>, <span class="number">480700</span>, <span class="number">1081575</span>, <span class="number">2042975</span>, <span class="number">3268760</span>, <span class="number">4457400</span>, <span class="number">5200300</span>, <span class="number">5200300</span>, <span class="number">4457400</span>, <span class="number">3268760</span>, <span class="number">2042975</span>, <span class="number">1081575</span>, <span class="number">480700</span>, <span class="number">177100</span>, <span class="number">53130</span>, <span class="number">12650</span>, <span class="number">2300</span>, <span class="number">300</span>, <span class="number">25</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">26</span>, <span class="number">325</span>, <span class="number">2600</span>, <span class="number">14950</span>, <span class="number">65780</span>, <span class="number">230230</span>, <span class="number">657800</span>, <span class="number">1562275</span>, <span class="number">3124550</span>, <span class="number">5311735</span>, <span class="number">7726160</span>, <span class="number">9657700</span>, <span class="number">10400600</span>, <span class="number">9657700</span>, <span class="number">7726160</span>, <span class="number">5311735</span>, <span class="number">3124550</span>, <span class="number">1562275</span>, <span class="number">657800</span>, <span class="number">230230</span>, <span class="number">65780</span>, <span class="number">14950</span>, <span class="number">2600</span>, <span class="number">325</span>, <span class="number">26</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">27</span>, <span class="number">351</span>, <span class="number">2925</span>, <span class="number">17550</span>, <span class="number">80730</span>, <span class="number">296010</span>, <span class="number">888030</span>, <span class="number">2220075</span>, <span class="number">4686825</span>, <span class="number">8436285</span>, <span class="number">13037895</span>, <span class="number">17383860</span>, <span class="number">20058300</span>, <span class="number">20058300</span>, <span class="number">17383860</span>, <span class="number">13037895</span>, <span class="number">8436285</span>, <span class="number">4686825</span>, <span class="number">2220075</span>, <span class="number">888030</span>, <span class="number">296010</span>, <span class="number">80730</span>, <span class="number">17550</span>, <span class="number">2925</span>, <span class="number">351</span>, <span class="number">27</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">28</span>, <span class="number">378</span>, <span class="number">3276</span>, <span class="number">20475</span>, <span class="number">98280</span>, <span class="number">376740</span>, <span class="number">1184040</span>, <span class="number">3108105</span>, <span class="number">6906900</span>, <span class="number">13123110</span>, <span class="number">21474180</span>, <span class="number">30421755</span>, <span class="number">37442160</span>, <span class="number">40116600</span>, <span class="number">37442160</span>, <span class="number">30421755</span>, <span class="number">21474180</span>, <span class="number">13123110</span>, <span class="number">6906900</span>, <span class="number">3108105</span>, <span class="number">1184040</span>, <span class="number">376740</span>, <span class="number">98280</span>, <span class="number">20475</span>, <span class="number">3276</span>, <span class="number">378</span>, <span class="number">28</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">29</span>, <span class="number">406</span>, <span class="number">3654</span>, <span class="number">23751</span>, <span class="number">118755</span>, <span class="number">475020</span>, <span class="number">1560780</span>, <span class="number">4292145</span>, <span class="number">10015005</span>, <span class="number">20030010</span>, <span class="number">34597290</span>, <span class="number">51895935</span>, <span class="number">67863915</span>, <span class="number">77558760</span>, <span class="number">77558760</span>, <span class="number">67863915</span>, <span class="number">51895935</span>, <span class="number">34597290</span>, <span class="number">20030010</span>, <span class="number">10015005</span>, <span class="number">4292145</span>, <span class="number">1560780</span>, <span class="number">475020</span>, <span class="number">118755</span>, <span class="number">23751</span>, <span class="number">3654</span>, <span class="number">406</span>, <span class="number">29</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            ret.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈哈哈哈哈哈哈哈</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;杨辉三角&quot;&gt;&lt;a href=&quot;#杨辉三角&quot; class=&quot;headerlink&quot; title=&quot;杨辉三角&quot;&gt;&lt;/a&gt;杨辉三角&lt;/h2&gt;&lt;p&gt;给定一个非负整数 &lt;em&gt;numRows&lt;/em&gt;，生成杨辉三角的前 &lt;em&gt;numRows&lt;/em&gt; 行。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-88. Merge Sorted Array（合并两个有序数组）</title>
    <link href="https://www.shuocloud.top/2018/01/20/LeetCode-88-Merge-Sorted-Array%EF%BC%88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/20/LeetCode-88-Merge-Sorted-Array%EF%BC%88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%89/</id>
    <published>2018-01-20T03:57:15.000Z</published>
    <updated>2021-01-20T06:50:46.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p>给定两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，将 <code>nums2</code> 合并到 <code>nums1</code> 中，使得 <code>num1</code> 成为一个有序数组。</p><a id="more"></a><p><strong>说明:</strong></p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 </li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li></ul><p>示例:</p><blockquote><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p></blockquote><h2 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a>Merge Sorted Array</h2><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p><strong>Note:</strong></p><ul><li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li><li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li></ul><p>Example:</p><blockquote><p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>Output: [1,2,2,3,5,6]</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>方法一：暴力法</strong></p><p>最朴素的方法就是合并数组，然后再排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != n; ++i) &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：正向双指针</strong></p><p>申请一个临时数组，设置两个头部指针，每次比较两个数组的头部，将较小的放入临时数组中，最后再将临时数组赋值给<code>nums1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sorted[m + n];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法三：逆向双指针</strong></p><p>我们注意到，在方法二中需要使用一个临时数组来防止<code>nums1</code>的元素被覆盖，如果我们逆向使用双指针则可以实现原地修改，证明如下：</p><p>设 $p1$ 和 $p2$ 是两个数组的尾部指针，即 $p1 = m-1$ ，$p2=n-1$，在遍历的某一时刻，<code>nums1</code>有$m-p1-1$个元素被放入<code>nums1</code>的后半部，<code>nums2</code>有$n-p2-1$个元素被放入<code>nums2</code>的后半部，而在 $p1$ 的后面有$m+n-p1-1$个位置。由于：</p><p>$$m+n-p1-1\geq m-p1-1+n-p2-1$$</p><p>等价于</p><p>$$p2\geq -1$$</p><p>永远成立，因此<code>nums1</code>后面有足够的位置容纳被插入的元素，可以实现原地修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;合并两个有序数组&quot;&gt;&lt;a href=&quot;#合并两个有序数组&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序数组&quot;&gt;&lt;/a&gt;合并两个有序数组&lt;/h2&gt;&lt;p&gt;给定两个有序整数数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;，将 &lt;code&gt;nums2&lt;/code&gt; 合并到 &lt;code&gt;nums1&lt;/code&gt; 中，使得 &lt;code&gt;num1&lt;/code&gt; 成为一个有序数组。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
    <category term="双指针" scheme="https://www.shuocloud.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="Two Pointers" scheme="https://www.shuocloud.top/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-66. Plus One（加一）</title>
    <link href="https://www.shuocloud.top/2018/01/20/LeetCode-66-Plus-One%EF%BC%88%E5%8A%A0%E4%B8%80%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/20/LeetCode-66-Plus-One%EF%BC%88%E5%8A%A0%E4%B8%80%EF%BC%89/</id>
    <published>2018-01-20T03:11:06.000Z</published>
    <updated>2021-01-20T06:49:56.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h2><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p></blockquote><h2 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a>Plus One</h2><p>Given a <strong>non-empty</strong> array of digits representing a <strong>non-negative</strong> integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p>Example 1:</p><blockquote><p>Input: [1,2,3]<br>Output: [1,2,4]<br>Explanation: The array represents the integer 123.</p></blockquote><p>Example 2:</p><blockquote><p>Input: [4,3,2,1]<br>Output: [4,3,2,2]<br>Explanation: The array represents the integer 4321.</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>根据题意，我们无需考虑负数的情况。（当然负数的做法也是类似）</p><p>非负数加法可以分为两类：</p><ol><li>非9的数字加一</li><li>9加一</li></ol><p>第一种情况，我们只需将原数字加一返回即可。</p><p>第二种情况，有进位。</p><p>因此我们可以将加一后的数字对10取余，如果不为0，则是第一种情况；如果为0，则有进位，遍历前一个元素，重复上述操作。</p><p>如果遍历循环能够全部执行完毕，则需要在数组的第一位增加一位1。例如<code>[9, 9]</code>需要变成<code>[1, 0, 0]</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            digits[i] = (++digits[i]) % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;加一&quot;&gt;&lt;a href=&quot;#加一&quot; class=&quot;headerlink&quot; title=&quot;加一&quot;&gt;&lt;/a&gt;加一&lt;/h2&gt;&lt;p&gt;给定一个由&lt;strong&gt;整数&lt;/strong&gt;组成的&lt;strong&gt;非空&lt;/strong&gt;数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。&lt;/p&gt;
&lt;p&gt;你可以假设除了整数 0 之外，这个整数不会以零开头。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-53. Maximum Subarray（最大子序和）</title>
    <link href="https://www.shuocloud.top/2018/01/12/LeetCode-53-Maximum-Subarray%EF%BC%88%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/12/LeetCode-53-Maximum-Subarray%EF%BC%88%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%89/</id>
    <published>2018-01-12T10:31:42.000Z</published>
    <updated>2021-01-20T06:49:33.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><a id="more"></a><p>示例:</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的<strong>分治法</strong>求解。</p><h2 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h2><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><blockquote><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p></blockquote><p><strong>Follow up:</strong></p><p>If you have figured out the O(n) solution, try coding another solution using <strong>the divide and conquer approach</strong>, which is more subtle.</p><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>方法一(动态规划)</strong><br>设数组<code>nums</code>的长度为$n$。</p><p>设$f(i)$为以<code>nums[i]</code>结尾的连续子数组的最大和，我们要求的就是：</p><p>$$\max \limits_{0\leq i\leq n-1}{f(i)}$$</p><p>因此我们只需要求出每个$f(i)$，然后取其最大值即可。在求$f(i)$的时候，我们要注意$f(i-1)$的值，如果它为负值，那么我们可以直接将其舍弃掉，因为一个数加上一个负数后会变小。由此，我们有状态转移方程：</p><p>$$f(i)=\max {f(i-1)+nums[i], nums[i]}$$</p><p>我们可以将空间复杂度优化到$O(1)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize;i++)&#123;</span><br><span class="line">        sum = (sum + nums[i]) &gt; nums[i] ? (sum + nums[i]) : nums[i];</span><br><span class="line">        max = sum &gt; max ? sum : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二（分治法）</strong><br>分成子问题解决。结构体中<code>l</code>表示数组中以最左侧数字起的连续最大值，<code>max</code>表示数组中的连续最大值，<code>r</code>表示数组中以最右侧数字为终点的连续最大值，<code>sum</code>表示数组之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">val</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (a &gt; b ? b : a)</span></span><br><span class="line"><span class="function">struct val <span class="title">maxSub</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">val</span> <span class="title">t</span> =</span> &#123;nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">val</span> <span class="title">v1</span> =</span> maxSub(nums, n / <span class="number">2</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">val</span> <span class="title">v2</span> =</span> maxSub(nums + n / <span class="number">2</span>, n - n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> l = max(v1.l, v1.sum + v2. l);</span><br><span class="line">    <span class="keyword">int</span> max = max(max(v1.max, v2.max), v1.r + v2.l);</span><br><span class="line">    <span class="keyword">int</span> r = max(v2.r, v1.r + v2.sum);</span><br><span class="line">    <span class="keyword">int</span> sum = v1.sum + v2.sum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">val</span> <span class="title">t</span> =</span> &#123;l, max, r, sum&#125;;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">val</span> <span class="title">v</span> =</span> maxSub(nums, numsSize);</span><br><span class="line">    <span class="keyword">return</span> v.max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转 载</span></span><br></pre></td></tr></table></figure><p><strong>方法三（贪心算法）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sum - min &gt; max)</span><br><span class="line">            max = sum - min;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; min)</span><br><span class="line">            min = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最大子序和&quot;&gt;&lt;a href=&quot;#最大子序和&quot; class=&quot;headerlink&quot; title=&quot;最大子序和&quot;&gt;&lt;/a&gt;最大子序和&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
    <category term="分治算法" scheme="https://www.shuocloud.top/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.shuocloud.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Divide and Conquer" scheme="https://www.shuocloud.top/tags/Divide-and-Conquer/"/>
    
    <category term="Dynamic Programming" scheme="https://www.shuocloud.top/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-35. Search Insert Position（搜索插入位置）</title>
    <link href="https://www.shuocloud.top/2018/01/12/LeetCode-35-Search-Insert-Position%EF%BC%88%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/12/LeetCode-35-Search-Insert-Position%EF%BC%88%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%89/</id>
    <published>2018-01-12T10:30:42.000Z</published>
    <updated>2021-01-20T06:48:05.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><a id="more"></a><p>示例 1:</p><blockquote><p>输入: [1,3,5,6], 5<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [1,3,5,6], 2<br>输出: 1</p></blockquote><p>示例 3:</p><blockquote><p>输入: [1,3,5,6], 7<br>输出: 4</p></blockquote><p>示例 4:</p><blockquote><p>输入: [1,3,5,6], 0<br>输出: 0</p></blockquote><h2 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a>Search Insert Position</h2><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p>Example 1:</p><blockquote><p>Input: [1,3,5,6], 5<br>Output: 2</p></blockquote><p>Example 2:</p><blockquote><p>Input: [1,3,5,6], 2<br>Output: 1</p></blockquote><p>Example 3:</p><blockquote><p>Input: [1,3,5,6], 7<br>Output: 4</p></blockquote><p>Example 4:</p><blockquote><p>Input: [1,3,5,6], 0<br>Output: 0</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>二分查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>另外，我们还可以使用c++的STL</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(),nums.end(),target) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lower_bound()</code>也是用二分法实现的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;搜索插入位置&quot;&gt;&lt;a href=&quot;#搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;搜索插入位置&quot;&gt;&lt;/a&gt;搜索插入位置&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;你可以假设数组中无重复元素。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
    <category term="二分查找" scheme="https://www.shuocloud.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="Binary Search" scheme="https://www.shuocloud.top/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-27. Remove Element（移除元素）</title>
    <link href="https://www.shuocloud.top/2018/01/12/LeetCode-27-Remove-Element%EF%BC%88%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/12/LeetCode-27-Remove-Element%EF%BC%88%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%89/</id>
    <published>2018-01-12T10:29:42.000Z</published>
    <updated>2021-01-20T06:47:00.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>给定一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><a id="more"></a><p>示例 1:</p><blockquote><p>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);<br>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>print(nums[i]);<br>}</p></blockquote><h2 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h2><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>Example 1:</p><blockquote><p>Given nums = [3,2,2,3], val = 3,<br>Your function should return length = 2, with the first two elements of nums being 2.<br>It doesn’t matter what you leave beyond the returned length.</p></blockquote><p>Example 2:</p><blockquote><p>Given nums = [0,1,2,2,3,0,4,2], val = 2,<br>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.<br>Note that the order of those five elements can be arbitrary.<br>It doesn’t matter what values are set beyond the returned length.</p></blockquote><p><strong>Clarification:</strong></p><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><blockquote><p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeElement(nums, val);<br>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>print(nums[i]);<br>}</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>这道题其实和<a href="https://ichen2000.com/2018/01/12/LeetCode-26-Remove-Duplicates-from-Sorted-Array%EF%BC%88%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%89/" target="_blank">LeetCode26题删除重复元素</a>相同的道理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[count++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h2&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要原地移除所有数值等于 &lt;code&gt;val&lt;/code&gt; 的元素，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;
&lt;p&gt;元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
    <category term="双指针" scheme="https://www.shuocloud.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="Two Pointers" scheme="https://www.shuocloud.top/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-26. Remove Duplicates from Sorted Array（删除排序数组中的重复项）</title>
    <link href="https://www.shuocloud.top/2018/01/12/LeetCode-26-Remove-Duplicates-from-Sorted-Array%EF%BC%88%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/12/LeetCode-26-Remove-Duplicates-from-Sorted-Array%EF%BC%88%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%89/</id>
    <published>2018-01-12T09:29:42.000Z</published>
    <updated>2021-01-20T06:46:55.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><a id="more"></a><p>示例 1:</p><blockquote><p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);<br>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p></blockquote><h2 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h2><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>Example 1:</p><blockquote><p>Given nums = [1,1,2],<br>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.<br>It doesn’t matter what you leave beyond the returned length.</p></blockquote><p>Example 2:</p><blockquote><p>Given nums = [0,0,1,1,1,2,2,3,3,4],<br>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.<br>It doesn’t matter what values are set beyond the returned length.</p></blockquote><p><strong>Clarification:</strong></p><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><blockquote><p>// nums is passed in by reference. (i.e., without making a copy)<br>int len = removeDuplicates(nums);<br>// any modification to nums in your function would be known by the caller.<br>// using the length returned by your function, it prints the first len elements.<br>for (int i = 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>双指针法</strong></p><p>设置两个指针，一个慢指针<code>i</code>，一个快指针<code>j</code>。只要 $nums[i]==nums[j]$， 就增加<code>j</code>。</p><p>当$nums[i]!=nums[j]$时，说明重复项已经遍历过了，因此我们将$nums[j]$的值赋给$nums[i+1]$，递增<code>i</code>，然后重复上述过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j])&#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;#删除排序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除排序数组中的重复项&quot;&gt;&lt;/a&gt;删除排序数组中的重复项&lt;/h2&gt;&lt;p&gt;给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。&lt;/p&gt;
&lt;p&gt;不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="https://www.shuocloud.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Array" scheme="https://www.shuocloud.top/tags/Array/"/>
    
    <category term="双指针" scheme="https://www.shuocloud.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="Two Pointers" scheme="https://www.shuocloud.top/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21. Merge Two Sorted Lists（合并两个有序链表）</title>
    <link href="https://www.shuocloud.top/2018/01/12/LeetCode-21-Merge-Two-Sorted-Lists%EF%BC%88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    <id>https://www.shuocloud.top/2018/01/12/LeetCode-21-Merge-Two-Sorted-Lists%EF%BC%88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%89/</id>
    <published>2018-01-12T09:14:59.000Z</published>
    <updated>2021-01-20T06:45:58.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><a id="more"></a><h2 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>Example:</p><blockquote><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p><strong>方法一：递归</strong></p><p>递归结束条件为：任意一个链表为空。</p><p>每次返回两个链表中较小的一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：迭代</strong></p><p>在两个链表中分别设置一个结点<code>prev</code>，然后比较这两个结点，将较小的那个插入新链表中，并将该结点后移，如此下去，直到某一个链表为空。由上述的步骤可知，剩下的链表的所有元素一定比新链表中的大，因此直接插入到新链表尾部即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ListNode* prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">        prev-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注：题解为官方题解。链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;合并两个有序链表&quot;&gt;&lt;a href=&quot;#合并两个有序链表&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表&quot;&gt;&lt;/a&gt;合并两个有序链表&lt;/h2&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;br&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/categories/LeetCode/"/>
    
    <category term="简单" scheme="https://www.shuocloud.top/categories/LeetCode/%E7%AE%80%E5%8D%95/"/>
    
    
    <category term="LeetCode" scheme="https://www.shuocloud.top/tags/LeetCode/"/>
    
    <category term="递归" scheme="https://www.shuocloud.top/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="链表" scheme="https://www.shuocloud.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Recursion" scheme="https://www.shuocloud.top/tags/Recursion/"/>
    
    <category term="Linked List" scheme="https://www.shuocloud.top/tags/Linked-List/"/>
    
  </entry>
  
</feed>
